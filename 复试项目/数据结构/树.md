---
tags:
  - 数据结构
---
- **求节点的个数**
![[Pasted image 20250404195720.png|500]]
- **总结点数（至多）**
![[Pasted image 20250404195922.png|500]]
- **高度为$h$的$m$叉树最多的节点个数**
![[Pasted image 20250404201006.png|500]]
- **二叉树**
![[Pasted image 20250404201137.png|500]]
	![[Pasted image 20250404201433.png|500]]
	![[Pasted image 20250404201537.png|500]]
- 先序遍历
- 中序遍历：投影
- 后序遍历
```cpp
#include <iostream>
using namespace std;
// ! 实验数据: -+a##*b##-c##d##/e##f##
typedef struct BiTNode
{
    char data;                       // 数据域
    struct BiTNode *lchild, *rchild; // 指针域：左、右孩子指针
} BiTNode, *BiTree;

// ! 初始化二叉树
void InitTreeRoot(BiTree &root)
{
    root = NULL;
}

// ! 添加新结点
void InsertBiTNode(BiTree &root)
{
    char ch;
    cin >> ch;
    if (ch == '#')
    {
        root = NULL;
    }
    else
    {
        root = (BiTree)malloc(sizeof(BiTree));
        root->data = ch;
        InsertBiTNode(root->lchild);
        InsertBiTNode(root->rchild);
    }
}

// ! 先序遍历
void ProOrder(BiTree root)
{
    if (root == NULL)
    {
        return;
    }
    cout << root->data << " ";
    ProOrder(root->lchild);
    ProOrder(root->rchild);
}

// ! 中序遍历
void MiddleOrder(BiTree root)
{
    if (root == NULL)
    {
        return;
    }
    MiddleOrder(root->lchild);
    cout << root->data << " ";
    MiddleOrder(root->rchild);
}

// ! 后序遍历
void PostOrder(BiTree root)
{
    if (root == NULL)
    {
        return;
    }
    PostOrder(root->lchild);
    PostOrder(root->rchild);
    cout << root->data << " ";
}

// ! 求树的深度
int TreeDepth(BiTree root)
{
    if (root == NULL)
    {
        return 0;
    }
    int l = TreeDepth(root->lchild);
    int r = TreeDepth(root->rchild);
    return l > r ? l + 1 : r + 1;
}

int main()
{
    BiTree biTree;
    InitTreeRoot(biTree);
    InsertBiTNode(biTree);
    cout << "先 序 遍 历: ";
    ProOrder(biTree);
    cout << endl
         << "中 序 遍 历: ";
    MiddleOrder(biTree);
    cout << endl
         << "后 序 遍 历: ";
    PostOrder(biTree);
    cout << endl
         << "树的深度：" << TreeDepth(biTree);
    return 0;
}
```
![[Pasted image 20250404210516.png|500]]
[根据二叉树的遍历结果确定二叉树](https://www.bilibili.com/video/BV1p54y197jd/?spm_id_from=333.337.search-card.all.click&vd_source=3d2791294cba8bd1dc5967d7f4d7dbcd)

---
- **二叉排序树（BST）**
	- 中序遍历得到有序序列
	- 构建：小左大右、第一个数作为root
		- ASL(成功) ：
			1. 总个数
			2. 每个数的查找次数
		- ASL(失败)：
			1. 总个数
			2. 找不到的叶子节点查找总合
	- 删除：
		1. 叶子：直接删除
		2. 没有右子树或左子树：直接用子树替换
		3. 有右子树和左子树，中序遍历下的相邻节点替换
- **平衡二叉树（AVL）**
	- [平衡二叉树](https://blog.csdn.net/m0_37914588/article/details/103754959)
	- 二叉搜索树（前提）
		1. 左子树高 - 右子树高<=1
	- 平衡：
		1. 冲突的左孩子变右孩子
		2. 冲突的右孩子变左孩子
		- LL型
		- RR型
		- LR型：插入位置在左孩子的右孩子上，先对先左旋左孩子，再右旋
		- RL型：插入位置在右孩子的左孩子上，先对先右旋左孩子，再左旋
		![[tempFileForShare_20250405-103925.jpg|550]]
	- 插入
	![[Pasted image 20250405104157.png|600]]
	- 删除
	![[Pasted image 20250405104523.png|600]]
- **哈夫曼树（带权路径长度最小的树）**
		![[Pasted image 20250405111338.png|550]]
	- 构造：
		![[Pasted image 20250405111443.png|550]]
